listing_task:
  description: >
    You are given a string of a json containing data of guitar listings. You will take this input and organize it in the specified pydantic format. Here is your input
      "listingGuitars": [
        
          "Model": "WINZZ 40-Inch Beginner Cutaway Acoustic Guitar",
          "Price": 150.0,
          "Condition": "new"
        
          "Model": "Brand New Yamaha APX2TEW Acoustic Guitar, 3/4 size",
          "Price": 240.0,
          "Condition": "new"
        ,
        
          "Model": "AIERSI Telecaster Guitars",
          "Price": 100.0,
          "Condition": "new"
        ,
        
          "Model": "Guitar",
          "Price": 75.0,
          "Condition": "used_like_new"
        ,
        
          "Model": "Yamaha Guitar",
          "Price": 100.0,
          "Condition": "used_like_new"
        ,
        
          "Model": "Star caster electric guitar",
          "Price": 400.0,
          "Condition": "used_like_new"
        ,
        
          "Model": "Acoustic and Electric Guitar with accessories",
          "Price": 185.0,
          "Condition": "used_good"
        ,
        
          "Model": "Acoustic Guitar",
          "Price": 40.0,
          "Condition": "used_good"
        ,
        
          "Model": "Guitar",
          "Price": 25.0,
          "Condition": "used_good"
        
      
  expected_output: >
    
    The output will need to be in the form of a nested json with this structure. With only the Listing Guitars filled out.
    class GuitarData(BaseModel):
      Model: str
      Price: float
      Condition: str

    class ListingJson(BaseModel):
      marketGuitars: List[GuitarData]  
      listingGuitars: List[GuitarData] 
  agent: listing_finder


img_analyze_task:
  description: > 
    Use the provided tool to analyze the images of the listing. Provide the tool with the ListingJson data object. Pass the tool
    the json as a string. The tool will return the same format you 
    put into the function except with the new names. Delete the entire old ListingJson object and create a new one. In the new ListingJson
    object only include entries that have a Model that was found by the tool. If a model cannot be determined do not include it.
    If a model is determined then change that entry to be only the Model name.
  expected_output: >
    The output will need to be in the form of a nested json with this structure. With only the Listing Guitars filled out.
    class GuitarData(BaseModel):
      Model: str
      Price: float
      Condition: str

    class ListingJson(BaseModel):
      marketGuitars: List[GuitarData]  
      listingGuitars: List[GuitarData] 
  agent: img_comparison

market_task:
  description: >
    You are given data on market guitars. If there is sufficent data you will need to put it into the marketGuitars of the pydantic json.
    Here is your data: 
    
      "marketGuitars": [
        
          "Model": "Yamaha APXT2EW",
          "Price": 239.99,
          "Condition": "new"
        ,
        
          "Model": "Guitar",
          "Price": 699.99,
          "Condition": "new"
        ,
        
          "Model": "Aiersi TL-10",
          "Price": 199.99,
          "Condition": "new"
        ,
        
          "Model": "Star caster electric guitar",
          "Price": 1199.99,
          "Condition": "new"
        ,
        
          "Model": "Epiphone Les Paul Special",
          "Price": 225.99,
          "Condition": "new"
        ,
        
          "Model": "Fender Stratocaster",
          "Price": 599.99,
          "Condition": "new"
        
      ],
      "listingGuitars": [
        
          "Model": "WINZZ 40-Inch Beginner Cutaway Acoustic Guitar",
          "Price": 150.0,
          "Condition": "new"
        ,
        
          "Model": "Yamaha APXT2EW",
          "Price": 240.0,
          "Condition": "new"
        ,
        
          "Model": "Aiersi TL-10",
          "Price": 100.0,
          "Condition": "new"
        ,
        
          "Model": "Fender Starcaster",
          "Price": 400.0,
          "Condition": "used_like_new"
        ,
        
          "Model": "Epiphone Les Paul Special",
          "Price": 185.0,
          "Condition": "used_good"
        ,
        
          "Model": "Ashthorpe Model B24",
          "Price": 25.0,
          "Condition": "used_good"
        
      ]
    
    
  expected_output: >
    The output will need to be in the form of a nested json with this structure. With you only filling in data in the marketGuitars
    class GuitarData(BaseModel):
      Model: str
      Price: float
      Condition: str

    class ListingJson(BaseModel):
      marketGuitars: List[GuitarData]  
      listingGuitars: List[GuitarData] 


  agent: market_value_finder

comparison_task:
  description: >
    Using the comparison tool give the newest ListingJson data structure. Pass the json into the tool as a string. You then use
    the email tool with this email: Email: {email}
  expected_output: > 
    No output other than sending an email. 
  agent: comparison_agent